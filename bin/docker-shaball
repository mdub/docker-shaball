#! /usr/bin/env ruby

require "clamp"
require "digest/sha1"
require "fileutils"

Clamp do

  self.description = "Bundle docker images into a tar-ball, with a unique name based on content"

  option "--pull", :flag, "pull the named images first"
  option "--force", :flag, "force re-generation of output file"

  option "--manifest", :flag, "just print the image manifest"

  parameter "IMAGE ...", "image name"

  def execute
    if pull?
      image_names.each do |name|
        system("docker pull #{name} > /dev/null")
        signal_error("docker pull failed") unless $?.success?
      end
    end
    if manifest?
      puts image_manifest
      return
    end
    manifest_checksum = Digest::SHA1.hexdigest(image_manifest)
    output_file_name = "#{manifest_checksum}.tar.gz"
    unless !force? && File.exist?(output_file_name)
      save_images(image_names, output_file_name)
    end
    puts output_file_name
  end

  private

  def save_images(image_names, output_file_name)
    FileUtils.safe_unlink(output_file_name)
    tmp_file_name = "#{output_file_name}.tmp"
    r, w = IO.pipe
    save = spawn("docker save #{image_names.join(' ')}", :out => w)
    gzip = spawn("gzip", :in => r, :out => [tmp_file_name, "w"])
    r.close
    w.close
    Process.wait save
    signal_error("docker save failed") unless $?.success?
    Process.wait gzip
    signal_error("gzip failed") unless $?.success?
    File.rename(tmp_file_name, output_file_name)
  end

  def image_names
    image_list.map do |name|
      name += ":latest" unless name.index(":")
      name
    end.uniq.sort
  end

  def image_manifest
    inspect_output = `docker inspect -f '{{ .Config.Image }}' #{image_names.join(" ")}`
    signal_error("docker inspect returned error") unless $?.success?
    image_ids = inspect_output.lines.map(&:strip)
    image_names.zip(image_ids).map do |image_name_and_id|
      image_name_and_id.join(" ") + "\n"
    end.join
  end

end
